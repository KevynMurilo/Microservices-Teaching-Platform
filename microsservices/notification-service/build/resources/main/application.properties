# ==================================================
# APPLICATION
# ==================================================
spring.application.name=notification-service
server.port=8083

# ==================================================
# DATABASE (PostgreSQL - database-per-service pattern)
# Each microservice owns its database. Never share databases between services.
# Docs: https://docs.spring.io/spring-boot/reference/data/sql.html
# ==================================================
spring.datasource.url=jdbc:postgresql://${DB_HOST:localhost}:${DB_PORT:5435}/notificationdb
spring.datasource.username=${DB_USERNAME:notification_user}
spring.datasource.password=${DB_PASSWORD:notification_pass}
spring.datasource.driver-class-name=org.postgresql.Driver

# Flyway manages the schema — Hibernate only validates it matches the entities.
# Never use ddl-auto=update in production: it can silently alter your schema.
# Docs: https://documentation.red-gate.com/fd
spring.jpa.hibernate.ddl-auto=validate
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.flyway.enabled=true
spring.flyway.locations=classpath:db/migration

# ==================================================
# RABBITMQ
# Docs: https://www.rabbitmq.com/tutorials/tutorial-one-spring-amqp
# ==================================================
spring.rabbitmq.host=${SPRING_RABBITMQ_HOST:localhost}
spring.rabbitmq.port=5672
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest

# After all retries, rejected messages go to DLQ instead of being requeued endlessly.
spring.rabbitmq.listener.simple.default-requeue-rejected=false

# Propagates trace context (traceId/spanId) through RabbitMQ messages.
# This is what makes distributed tracing work across async boundaries.
spring.rabbitmq.listener.simple.observation-enabled=true

# Custom properties (externalized names — never hardcode queue names in Java)
# Fan-out pattern: the notification-service binds its OWN queues to the SAME exchanges
# used by order-service and payment-service. Each service gets its own copy of the message.
# This is the key advantage of TopicExchange over DirectExchange.
flash.rabbitmq.exchange.orders=orders.exchange
flash.rabbitmq.queue.order-notifications=orders.v1.queue.notifications
flash.rabbitmq.routing-key.order-created=orders.v1.created

flash.rabbitmq.exchange.payments=payments.exchange
flash.rabbitmq.queue.payment-notifications=payments.v1.queue.notifications
flash.rabbitmq.routing-key.payment-processed=payments.v1.processed

# ==================================================
# OBSERVABILITY
# Docs: https://micrometer.io/docs/tracing
# ==================================================
management.endpoints.web.exposure.include=health,info,metrics,prometheus
management.endpoint.health.show-details=always
management.metrics.tags.application=${spring.application.name}

# Distributed tracing: sends spans to Jaeger via OTLP protocol.
# 1.0 = sample 100% of requests (use lower values in production for cost control).
management.tracing.sampling.probability=1.0
management.otlp.tracing.endpoint=http://${JAEGER_HOST:localhost}:4318/v1/traces

# ==================================================
# LOGGING
# ==================================================
logging.level.com.notificationservice=DEBUG
logging.level.org.springframework.amqp=INFO
